"""
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""

from __future__ import annotations

import sys
import urllib.parse
from decimal import DivisionByZero, InvalidOperation, Overflow
from typing import TYPE_CHECKING

import aiohttp
import discord
import pyparsing as pyp
from discord import app_commands
from discord.app_commands import locale_str as _
from discord.ext import commands

from ...core import commands as cmds
from ...core.context import Context
from ...core.embed import Field, ZEmbed, ZEmbedBuilder
from ...core.mixin import CogMixin
from ...utils.api.googletrans import GoogleTranslate
from ...utils.api.piston import Piston
from ...utils.other import NumericStringParser, decodeMorse, encodeMorse, parseCodeBlock


if TYPE_CHECKING:
    from ...core.bot import ziBot


class Utilities(commands.Cog, CogMixin):
    """Useful commands."""

    icon = "ðŸ”§"
    cc = True

    def __init__(self, bot: ziBot):
        super().__init__(bot)
        self.piston = Piston(session=self.bot.session, loop=self.bot.loop)
        self.googletrans = GoogleTranslate(session=self.bot.session)

    @cmds.command(
        name=_("calc"),
        aliases=["math", "c"],
        description=_("calc-desc"),
        hybrid=True,
        extras=dict(
            example=(
                "calc 12*6",
                "c 5^5",
                "math 50/2",
            )
        ),
    )
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def calc(self, ctx, *, equation: str):
        formattedResult: _
        result: _ | str
        key = "calc-result"
        try:
            _result = NumericStringParser().eval(equation)
            if _result > sys.maxsize:
                formattedResult = _(key + "-too-large")
            else:
                formattedResult = _("calc-result", number=_result)
            result = str(_result)
        except Overflow:
            formattedResult, result = (_(key + "-infinite"),) * 2
        except (InvalidOperation, DivisionByZero):
            formattedResult, result = (_(key + "-error"),) * 2
        except Exception as e:
            return await ctx.send("I couldn't read that expression properly.")

        e = ZEmbedBuilder(
            fields=[
                Field(_("calc-equation-title"), discord.utils.escape_markdown(equation)),
                Field(_("calc-result-title"), formattedResult),
                Field(_("calc-raw-result-title"), result),
            ],
        )
        e.setAuthor(name=_("calc-author"), iconUrl=ctx.bot.user.avatar.url)
        return await ctx.try_reply(embed=await e.build(ctx, autoGenerateDT=True, addRequester=True))

    # TODO: Slash - Multiline sucks with slash
    @commands.command(
        aliases=("exec", "run"),
        description="Execute a code",
        help=(
            "\nWill executes python code by default if there's no language specified\n\n"
            "**Usage**:\n"
            ">execute \`\`\`language\ncodes\n\`\`\`\n"  # type: ignore # noqa: W605
            ">execute \`python code\`\n"  # type: ignore # noqa: W605
        ),
        # extras=dict(example=('execute print("Hello World")',)),
    )
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def execute(self, ctx, *, argument):
        lang, code = parseCodeBlock(argument)

        async with ctx.loading():
            f = discord.File("./assets/img/piston.png", filename="piston.png")
            executed = await self.piston.run(lang, code)

            e = ZEmbed.default(ctx)
            e.set_author(
                name="Piston API - {}-{}".format(executed.language, executed.version),
                icon_url="attachment://piston.png",
            )

            if executed.message:
                e.description = "```diff\n- {}```".format(executed.message)
            else:
                e.description = "```ini\n{}\n[status] Return code {}```".format(
                    executed.stderr or executed.stdout, executed.code
                )

            await ctx.try_reply(embed=e, file=f)

    # TODO: Slash, need to adapt the args
    @commands.command(
        aliases=("tr", "trans"),
        description="Translate a text",
        extras=dict(example=("translate fr->en Bonjour", "trans id Hola", "tr en<-ja ã“ã‚“ã«ã¡ã¯")),
    )
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def translate(self, ctx, language, *, text):
        # parse "source->dest" or "dest<-source"
        arrow = pyp.Literal("->") | pyp.Literal("<-")
        lang = pyp.Word(pyp.alphas) + pyp.Optional(arrow + pyp.Word(pyp.alphas))
        parsed = lang.parseString(language)

        kwargs = {}
        try:
            kwargs["dest"] = parsed[2] if parsed[1] == "->" else parsed[0]
            kwargs["source"] = parsed[0] if parsed[1] == "->" else parsed[2]
        except IndexError:
            kwargs["dest"] = parsed[0]

        translated = await self.googletrans.translate(text, **kwargs)
        if not translated:
            return await ctx.error("Translation failed. Please try again later...")

        e = ZEmbed.default(ctx)
        e.set_author(name="Google Translate", icon_url="https://translate.google.com/favicon.ico")
        e.add_field(name="Source [{}]".format(translated.source), value=translated.origin)
        e.add_field(name="Translated [{}]".format(translated.dest), value=str(translated))
        return await ctx.try_reply(embed=e)

    @cmds.command(name=_("morse"), description=_("morse-desc"), hybrid=True)
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def morse(self, ctx, *, text: str):
        try:
            await ctx.try_reply(f"`{encodeMorse(text)}`")
        except KeyError:
            await ctx.error(_("morse-error"), title=_("morse-error-title"))

    @cmds.command(
        name=_("unmorse"),
        aliases=("demorse",),
        description=_("unmorse-desc"),
        hybrid=True,
        usage="(morse code)",
    )
    @commands.cooldown(1, 5, commands.BucketType.user)
    async def unmorse(self, ctx, *, code: str):
        try:
            await ctx.try_reply(f"`{decodeMorse(code)}`")
        except ValueError:
            await ctx.error(_("unmorse-error"))

    @cmds.command(
        name=_("search"),
        aliases=("google", "g"),
        description=_("search-desc"),
        hybrid=True,
    )
    @app_commands.rename(query="keyword")
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def search(self, ctx: Context, *, query: str):
        async with ctx.loading():
            async with ctx.session.get(
                f"http://{self.bot.config.internalApiHost}/api/v1/search?q={urllib.parse.quote(query)}"
            ) as resp:
                result = await resp.json()

                if not result:
                    if not ctx.interaction:
                        await msg.delete()  # type: ignore
                    return await ctx.error(
                        _("search-error", query=query),
                        title=_("search-error-title"),
                    )

                e = ZEmbedBuilder()
                e.setAuthor(name=_("search-result-title", query=query))

                resultStats = result["stats"]
                resultCount = resultStats["count"]
                resultDuration = resultStats["duration"]
                e.setFooter(
                    text=_(
                        "search-result-stats",
                        count=resultCount,
                        duration=resultDuration["value"],
                        unit=resultDuration["unit"],
                    ),
                )

                special = result.get("special")
                complementary = result.get("complementary")
                limit = 3

                if special:
                    limit -= 1
                    specialTitle: str = special["title"]
                    specialContent = special["content"]

                    i = specialTitle.lower()
                    if i.startswith("currency"):
                        from_ = specialContent["from"]
                        to = specialContent["to"]

                        e.addField(
                            name=_("search-rich-card-title", title=special["title"].title()),
                            value=_(
                                "search-currency",
                                value=from_["value"],
                                currency=from_["currency"],
                                resValue=to["value"],
                                resCurrency=to["currency"],
                                lastUpdated=specialContent["last_updated"],
                            ),
                        )
                    elif i.startswith("calculator"):
                        e.addField(
                            name=_("search-rich-card-title", title=special["title"].title()),
                            value=" ".join(specialContent.values()),
                        )
                    else:
                        e.addField(name=_("search-rich-card-title", title=special["title"].title()), value=specialContent)

                if complementary is not None:
                    limit -= 1
                    info = ""
                    for i in complementary["info"]:
                        a = i.split(":")
                        try:
                            info += f"**{a[0]}**: `{a[1].strip()}` \n"
                        except IndexError:
                            info += f"`{a[0]}`\n"
                    e.addField(
                        name=_("search-rich-card-title", title=complementary['title'] or 'Unknown'),
                        value=(f"`{complementary['subtitle'] or 'Unknown'}`\n" if complementary["subtitle"] else "")
                        + (complementary["description"] + "\n" if complementary["description"] else "")
                        + info,
                    )

                for res in result["sites"][:limit]:
                    try:
                        content = res["content"]
                    except IndexError:
                        content = ""
                    e.addField(name=res["title"], value=f"{res['link']}\n{content}")

                return await ctx.try_reply(embed=await e.build(ctx, autoGenerateDT=True, addRequester=True))

    @cmds.command(
        name=_("realurl"),
        description=_("realurl-desc"),
        usage="(shorten url)",
        hybrid=True,
    )
    @app_commands.rename(shortenUrl=_("realurl-arg-shorten-url"))
    @commands.cooldown(1, 10, commands.BucketType.user)
    async def realurl(self, ctx, shortenUrl: str):
        async with ctx.loading():
            try:
                async with ctx.bot.session.get(shortenUrl) as res:
                    e = ZEmbedBuilder(
                        title=_("realurl-title"),
                        description=_("realurl-result", query=shortenUrl, result=str(res.real_url)),
                    )
                    return await ctx.try_reply(embed=await e.build(ctx, autoGenerateDT=True, addRequester=True))
            except aiohttp.InvalidURL:
                return await ctx.error(_("realurl-error-url", url=shortenUrl), title=_("realurl-error-url-title"))
            except aiohttp.ClientConnectorError:
                return await ctx.error(
                    _("realurl-error-connection", url=shortenUrl),
                    title=_("realurl-error-connection-title"),
                )
